pair<int, int> p = {1, 3}
cout << p.first will produce 1 

pair<int, <int, int> p = {2, {6, 7}} // this is an example of nested pair
cout<< p.second.first will produce 6

pair<int, int> arr[] = {{1, 2} , {7, 8}} // pairs can be kept on arrays to like any others data type
arr[1].second gives us 8


// vetors is like array but it is dynamic in nature
vector<int> v; will create an empty container
v.push_back(1) will keep 1 in vector v 
v.emplace_back(2) will put 2 in back of 1 , now v will be like {1, 2} , generaly emplace_back() is faster than push_back()

vector<pair<int, int>> vec will create vector v of pair-data type elements
vec.push_back({1, 5}) will keep pair {1, 5} 
vec.emplace_back(7, 9) [see here we didn't need {} in argument section for inserting a pair] will keep pair {7, 9} after pair{1, 5}
vector<int> v(5, 100) will define a vector(one type of container) of size 5 with instances of 100
vector<int> v(5) will declare avecto with size 5 with instances of 0 or garbage_value depending on compiler
vector<int> v1(v) will declare another new vector same as vector v
vector<int> g is containing {4,5,6,7}
now cout<<g[0] or g.at(0) will give us 4

iterator??
vector<int> :: iterator it = g.begin() will pointing to memory adress of begining of vector g // this is example of iterator in vector
cout<<*(it) will produce 4
it++
cout<<*(it) will produce 5
it += 2
cout<<*(it) will produce 7
vector<int> :: iterator it = g.end() will point location right after 7 so if we now want to access 7 we first do it-- and then do *(it)
vector<int> :: iterator it = g.rend() will point the previous location of 4
vector<int> :: iterator it = g.rbegin() will point adress of 7 // generally rend() and rbegin() are not going to use
in rend() and  rbegin() moving(it-- & it++) will happen in reverese order


vector<int> h containing {5, 4, 20}
cout<<h.back() will print 20


for(vector<int>::iterator it = h.begin(); h != h.end(); it++) // traversing a vctor through iterator
	cout<<*(it)<<" ";
for(auto it = h.begin(); it != h.end(); it++) {
	cout<<*(it)<<" ";
// traversing vector h through for-each loop
for(auto it : h) {	// here it is not an iterator it is an integer data type
	cout<<it<<" ";	// auto is a smart data type which automatically assign neccesary data type to the variable
}

// erasing element from vector

// {10, 20, 12, 23}
v.erase(v.begin() + 1) will erase 20 from vector v and v will be reshuffled as {10, 12, 23}

// {10, 20, 12, 23, 35}
v.erase(v.begin() + 2, v.begin() + 4); // v will reshuffled as {10, 20, 35}, here is a catch see we give address of start of the range of deletion and we give adress of end of the deletion range,now this end adress is the adress of element after the last element we want to delete in deletion range;i.e end address is excluded from deletion range [start, end)

// insert function

vector<int> v(2, 100) // create {100, 100}

v.insert(v.begin(), 300); // insert 300 in the begining of vector v and v will look like {300, 100, 100}
v.insert(v.begin() + 1, 2, 10) // insert 2 occurance of 10 in index 1 ,vector will look like {300, 10, 10, 100, 100}

//inserting a vector into another vector

vector<int> copy(2, 50) // copy is a vector containing {50, 50}

v.insert(v.begin(), copy.begin(), copy.end()); // now v will look like {50, 50, 300, 10, 10, 100, 100}

// {10, 20}
vector<int> v;
cout << v.size() ; gives size of vector i.e how many elements in vector v

v.pop_back(); // pops out last element and v will now {10}

// v1 -> {10, 20}
// v2 -> {30, 40}
v1.swap(v2); // v1 -> {30, 40} and v2 -> {10, 20}

v.clear(); // erase the entire vector, trims down in a empty vector

v.empty() // check the vector is empty or not and will produce boolean value



// list starts here

it is also a dynamic container same as vector, list support front operation as well

list<int> ls;

ls.push_back(2); // {2}
ls.emplace_back(4); // {4}

ls.push_front(5); // {5, 2, 4}   notes: this operation can be performed in vector via insert() but that will be costly and time consuming (vector implemnted accordind to singly linked list) and list implemented as doubly linkd list so this same operation is faster and cheaper in list

ls.emplace_front(6); // {6, 5 ,2 , 4}

// rest functions are same as vector
// begin, end, rend, rbegin, clear, insert, size, empty, swap



// deque starts here

deque<int> dq;
dq.push_back(1); // {1}
dq.emplace_baack(2); // {1, 2}
dq.push_front(4); // {4, 1, 2}
dq.emplace_front(3); // {3, 4, 1, 2}

dq.pop_back(); // {3, 4, 1}
dq.pop_front(); // {4, 1}

dq.back();
dq.front()

// rest function same as vector
// begin, end, rend, rbegin, clear, insert, size, swap, empty


// stack starts here
stack follows last in first out (LIFO) principle

stack<int> st;

st.push(1); // {1}
st.push(2); // {2, 1}
st.push(3); // {3, 2, 1}
st.push(3); // {3, 3, 2, 1}
st.emplace(5); // {5, 3, 3, 2, 1}

// stack can't be accessed through indexes, all we have is top, pop, push and these operation have O(1) time cplexity

cout << st.top(); // prints 5 
st.pop(); // st looks like {3, 3, 2, 1}
cout << st.top(); // prints 3
cout << st.size(); // 4
cout << st.empty(); // false
stack<int> st1,st2;
st1.swap(st2);


// Queue starts here

queue folows First in First Out (FIFO) principle

queue<int> q;

q.push(1); // {1}
q.push(2); // {1, 2}
q.emplace(4); // {1, 2, 4}

q.back() =+ 5; // this will point to 4 and add 5 to it and yhe queue will be like {1, 2, 9}

cout << q.back(); // prints 9
cout << q.front(); // prints 1

q.pop(); // q will be {2, 9}
cout << q.front(); // prints 2

// all function's time complexity is O(1)
// size, swap, empty these function are similar like stack's


// Priority queue starts here
largest element will be given highest priority and that element will be in TOP (in string lexicographically largest string will be at top)
inside priority queue a tree maintained ;priority queue is maintained as a tree i.e it is implemented according to tree data structure

priority_queue<int> pq;

pq.push(5); // {5}
pq.push(2); // {5, 2}
pq.push(8); // {8, 5, 2}
pq.push(6); // {8, 6, 5, 2}
pq.emplace(10) // {10, 8, 6, 5, 2}

cout << pq.top(); // prints 10 
pq.pop(); // delete top element(here 10 is top element)
cout << pq.top(); // prints 8

size, empty, swap functions are same as others

// when I want a priority queue which store minimum element at top ,then syntax is following
priority_queue<int, vector<int>, greater<int>> pq; // here pq is a priority queue which store minimum element at Top

pq.push(5); // {5}
pq.push(2); // {2, 5}
pq.push(1); // {1, 2, 5}
pq.emplace{8}; // {1, 2, 5, 8}
